---
title: ES-第二部分
order: 2
---



# ES - Part Two

## 函数扩展

### 参数默认值

ES6 - 定义函数可以指定默认值。

- 参数变量是默认声明，不可用`let`或`const`再次声明
- 函数不能有同名参数
- 参数为惰性求值，每次都要重新计算
- 传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}
foo() // 100
x = 100;
foo() // 101
```

#### 参数默认值与解构

下面写法：不能省略第二个参数，对象中的属性有默认值，但是对象本身没有

```js
function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}
// 正确写法
// { body = '', method = 'GET', headers = {} } = {}
```

```js
// 解构的值赋予默认值
{x = 0, y = 0} = {} // {} - 0,0

// 解构的对象赋予默认值
{x, y} = { x: 0, y: 0 } // {} - undefined,undefined
```

#### 参数默认值位置

定义了默认值的参数，应该是**尾参数**。非尾参数，用`undefined`占位

```js
function f( x = 1, y ){}
f() // 1 undefined
f(,1) // 报错
f(undefined,1) // 1 1
f(2,1) // 2 1
```

#### 函数length属性

函数`length`属性：将返回**没有指定默认值的参数个数**。

`rest`参数也不会计入length。

默认值参数不是尾参数，length不会计入后面的参数

```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2

(function(...args) {}).length // 0

(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

#### 作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。

```js
// y = x 形成 单独作用域
// 实际执行 let y = x

function f( y = x ){
    let x = 0;
    console.log(x,y)
}
f(1)
```

```js
function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar() // ReferenceError: foo is not defined
```

`y`默认值为匿名函数，其中`x`指向同作用域第一个参数`x`。

`foo`函数内部变量 x 是与 `foo` 参数变量 `x` 不同

执行 `y()` 只会影响*参数变量*，*外部变量*和*内部变量*都不会改变

```js
var x = 1;
function foo(x, y = function() {  
    x = 2 // closure
}) {
  // local x - undefined
  var x = 3;
  // local x - 3
  y();
  // local x - 3
  console.log(x);
}
foo()
// global x - 1
```

与上面不同的是，*没有内部变量*，此时`x=3`中的`x`为参数变量。

```js
var x = 1;
function foo(x, y = function() { x = 2; }) {
  // x - undefined
  x = 3;
  // x - 3
  y();
  // x - 2
  console.log(x);
}

foo()
x // x - 1
```

#### 应用

参数默认值在运行时执行，利用参数默认值，让不填参数就报错

```js
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
```

### rest参数

ES6中，引入rest参数 （`...变量名`），用于获取多余参数，代替`arguments`

`arguments`：类数组对象

`rest`：数组，无需转换

```js
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```

rest参数后不能有其他参数，即*rest参数为最后一个参数*

```js
function f(a, ...b, c) {} // 报错
```

函数`length`属性，不包括rest参数

```js
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

### 严格模式

ES5，内部可以设定严格模式

```js
function doSomething(a, b) {
  'use strict';
  // code
}
```

ES2016，函数参数使用默认值，解构赋值，扩展运算符后，**不能显示定义为 严格模式**

严格模式适用于 函数内部和函数参数

原因：只有在函数体内才能知道是否以严格模式执行，但参数执行先于函数内部

```js
// 报错
function doSomething(value = 070) {
  'use strict';
  return value;
}
```

**报错分析**：严格模式下不能使用前缀 `0`表示八进制。执行`value=070`，进入函数内部，发现严格模式执行，所以报错。

**解决方案**

全局性严格模式

```js
'use strict';

function doSomething(value = 070) {
  return value;
}
```

包裹在无参数的立即执行函数里面

```js
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
```

### name属性

#### 匿名函数

```js
var f = function () {};
// ES5
f.name // ""
// ES6
f.name // "f"
```

#### 具名函数

赋值给变量，`name`属性为函数名（ES5，ES6相同）

```js
const bar = function baz() {};
// ES5
bar.name // "baz"
// ES6
bar.name // "baz"
```

#### 对象方法

使用了取值函数（`getter`）和存值函数（`setter`），函数名前加 `get` 和 `set`

```js
const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo"
```

对象方法是一个 Symbol 值，那么`name`属性返回的是这个 Symbol 值的描述

```js
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
```

构造函数：返回函数实例，`name`属性为`anonymous`

```js
(new Function).name // "anonymous"
```

bind：返回函数，`name`属性加上`bound`前缀

```js
function foo() {};
foo.bind({}).name // "bound foo"
(function(){}).bind({}).name // "bound "
```

### 箭头函数

`ES6`：箭头（`=>`）定义函数

#### 基础用法

函数参数：**不需要参数**或**多个**参数，圆括号代表参数部分

```js
() => 5;
(x, y) => x + y;
```

代码块：**多于一条**语句，对象外加`{}`,并且 `return` 语句返回

```js
(num1, num2) => { return num1 + num2; }
```

返回对象：因为大括号解析为代码块，箭头函数直接返回一个对象时，外层加上`()`

```js
() => { id: id, name: "Temp" } // 报错
() => ({ id: id, name: "Temp" }) // 正确
```

特殊情况：`{}`被解析为代码块，函数内部执行 `a:1`，无返回值

```js
let foo = () => { a: 1 };
foo() // undefined
```

无需返回值：单行语句，且**不需要返回值**

```js
let fn = () => void doesNotReturn();
```

解构、rest参数

```js
({ first, last }) => first + ' ' + last;
(...nums) => nums
```

#### 注意点

1. this指向固定，**定义时所在对象，而不是使用者所在对象**
2. 箭头函数没有自己的this，导致内部this指向外部this。没有this，不能用 call apply bind方法改变 this 指向
3. 不可做构造函数，不可以使用`new`命令
4. 没有`arguments`对象（不存在），使用`rest`参数代替
5. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数
6. `super、new.target` 在箭头函数中也是不存在，指向外层变量
7. `typeof` 判断箭头函数 结果为`function`
8. `instanceof` 判断是否`Function`实例 结果为true

```js
function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数 this -> timer
  setInterval(() => this.s1++, 1000);
  // 普通函数 this -> window
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
```

下面代码有几个`this`？

```js
function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
```

只有一个`this`，即`foo`的`this`，无论怎么嵌套，都会去获取 foo中的 id

#### 不适用场合

以下两种方法应使用传统写法，而非箭头对象

##### 定义对象的方法

对象中使用箭头函数：函数会指向对象所在作用域，此处是`window`，普通函数指向`obj`

```js
globalThis.s = 21; // globalThis 此处 -> window
const obj = {
  s: 42,
  m: () => console.log(this.s)
};

obj.m() // 21
```

##### 动态this

this应该动态指向，使用箭头函数后，this固化。

```js
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

#### 嵌套箭头函数

部署管道机制（pipeline）

```js
const pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);
```

**[?]**  λ 演算

```js
// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f => (x => f(v => x(x)(v)))
               (x => f(v => x(x)(v)));
```

### 尾调用优化

#### 尾调用

尾调用（Tail Call）：函数的最后一步是调用另一个函数

```js
function f(x){
  return g(x);
}
```

尾调用不一定出现在函数尾部，只要是最后一步操作

```js
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

#### 非尾调用

```js
// 情况一 - 函数之后还有别的操作
function f(x){
  let y = g(x);
  return y;
}

// 情况二 - 函数之后还有别的操作
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
  // return undefined
}
```

#### 尾调用优化

调用帧：函数调用会在内存形成调用记录，保存调用位置和内部变量信息。

调用栈：函数A调用B，会在A上方形成B调用帧。B返回结果后，B调用帧消失。如果B调用C，会B上方形成C调用帧。所有调用帧组成调用栈。

尾调用是函数最后一步操作，无需保留调用帧。因为调用位置、内部变量等信息都不会再用到。

尾调用优化（Tail call optimization）：保留内层函数的调用帧。如果所有函数都是尾调用，每次执行时，调用帧只有一项，这将大大节省内存。

> 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

#### 尾递归

问题：递归需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）

解决：函数尾调用自身，就称为尾递归。

尾递归关键：每次递归都在收集结果，避免线性递归展开消耗内存，只存在一个调用帧。

尾递归：只有一个调用帧

```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

非尾递归：2的n次方个调用帧

```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
```

#### 递归函数改写

所有用到的 内部变量 改写成 函数的参数。

缺点：不太直观，计算5阶乘，为何传1

```js
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

tailFactorial(5 , 1) // 120
```

方案1：外部提供正常函数

```js
function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
```

函数柯里化：多参数函数转为单参数函数

```js
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

const factorial = currying(tailFactorial, 1);
factorial(5) // 120
```

方案2：ES6默认值

```js
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

#### 严格模式

尾调用优化之只在严格模式下有用

因为正常模式下，存在`func.arugments`和`func.caller`，尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。

- `func.arguments`：返回调用时函数的参数。
- `func.caller`：返回调用当前函数的那个函数。

#### 尾递归优化实现

问题：尾递归优化只在严格模式下生效

解决：正常模式下，或者那些不支持该功能的环境中。通过采用 “循环” 换掉 “递归” ，减少调用栈

```js
function sum(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
```

蹦床函数（trampoline）可以将递归执行转为循环执行。这里是返回一个函数，然后执行函数，并非函数中调用函数，避免了递归执行。

```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
```

通过蹦床函数优化问题代码

```js
function sum(x, y) {
  if (y > 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
```

通过 sum 使每次返回一个新的函数，不会发生栈溢出

```js
trampoline(sum(1, 100000)) // 100001
```

==@DIF 尾调用优化：active原理==

```js
function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
```

#### 函数参数的尾逗号

*ES2017* 允许函数的最后一个参数有尾逗号（trailing comma）

#### Function.prototype.toString()

`Function.prototype.toString()`：返回函数代码本身，以前会省略注释和空格，ES2019 - 后不会省略注释。

```js
function /* foo comment */ foo () {}
foo.toString()
// "function /* foo comment */ foo () {}"
```

#### catch 命令的参数省略

`catch`代码块参数不可省略。

```js
try {
  // ...
} catch (err) {
  // 处理错误
}
```

*ES2019* - 允许`catch`语句省略参数。

```js
try {
  // ...
} catch {
  // ...
}
```

## 数组扩展

### 扩展运算符

扩展运算符（spread）：三个点（`...`），将一*个数组转为用逗号分隔*的参数序列。`rest`参数逆运算

- 与函数参数结合
- 放置表达式：`[...(x > 0 ? ['a'] : [])]`
- 空数组：不产生效果
- 函数调用时，扩展运算符才能放圆括号中

```js
(...[1, 2])
// Uncaught SyntaxError: Unexpected number
console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number
console.log(...[1, 2])
// 1 2
```

#### 替代apply方法

```js
// ES5
Math.max.apply(null, [14, 3, 77])
// ES6
Math.max(...[14, 3, 77])

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
```

#### 扩展运算符应用

1. 复制数组

直接赋值（`arr1=arr2`），只复制底层指针（浅拷贝）

以下代码`a1`会返回原数组的克隆，修改`a2`不影响`a1`。

```js
// ES5
const a1 = [1, 2];
const a2 = a1.concat();
// ES6
// 写法1
const a2 = [...a1];
// 写法2
const [...a2] = a1;

a2[0] = 2;
a1 // [1, 2]
```

2. 合并数组

浅拷贝

```js
const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
```

3. 解构赋值

与解构赋值结合起来，用于生成数组。

扩展运算符用于数组赋值，只能放在参数的*最后一位*

```js
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list

// 报错 - 扩展运算符为数组赋值，只能放最后
const [first, ...middle, last] = [1, 2, 3, 4, 5]; 
```

4. 字符串

将字符串转为真正的数组。

JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符。扩展运算符且能够正确识别四个字节的`Unicode`

```js
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
```

建议：涉及到操作四个字节的 Unicode 字符的函数，用扩展运算符改写。

```js
function length(str) {
  return [...str].length;
}
```

5. iterator接口对象

任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为**真正的数组**。如：

```js
let nodeList = document.querySelectorAll('div');
let array = [...nodeList];
```

6. Map 和 Set 结构，Generator 函数

```js
// Map
let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
// Generator
const go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]
```

没有 Iterator 接口的对象，使用扩展运算符，将会报错。

```js
const obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
```

### Array.form()

`Array.from`：将两类对象转为真正的数组

- 类似数组的对象（array-like object）
- 可遍历（iterable）的对象（Set 和 Map）

>如果**参数为数组**，将会**返回**一样的**新数组**

```js
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
// ES5
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
// ES6
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
// NodeList
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {})
```

第二参数：回调函数

```js
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);
```

**类数组对象**：必须有`length`属性。任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。因为扩展运算符调用的是**遍历器接口**（`Symbol.iterator`），如果没有部署这个接口，就无法转换。

```js
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```

**处理各种** Unicode **字符**，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符

```js
function countSymbols(string) {
  return Array.from(string).length;
}
```

polyfill

```js
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();
```

### Array.of()

`Array.of()`：将一组值，转换为数组。

- 弥补数组构造函数`Array()`的不足，参数不同，行为有差异
- 参数不少于2个才会组成新数组

Array构造函数问题：参数不同，行为不同

```js
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]

Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```

polyfill

```js
function ArrayOf(){
  return [].slice.call(arguments);
}
```

### 数组实例

#### copyWithin()

`copyWithin(target,start,end)`：将**指定位置**的成员**复制到其他位置**，然后返回当前数组。（**会改变当前数组**）

参数说明：

- target（**必需**）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始选取，默认为 0。如果为负值，表示从末尾开始计算。
- end（可选）：从该位置前停止，默认等于数组长度。如果为负值，表示从末尾开始计算。

>三个参数都应该是数值，如果不是，会自动转为数值。

```js
// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// [empty,empty,empty,1,empty] => [1,empty,empty,1,empty]
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// 3 4 5 -> 0
// Int32Array [3, 4, 5, 4, 5]

// 替换写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
```

#### find() ，findIndex()

`find(callback, bindThis)`：用于找出**第一个符合**条件的**数组成员**。

- 执行回调，找出第一个返回条件为true的成员

- 都不符合 返回 `undefined`

- 回调参数：` (value, index, arr)`

`findIndex(callback, bindThis)`：返回**第一个符合条件**的**数组成员的位置**

- 都不符合，返回 `-1`

```js
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

NaN问题：indexof 无法匹配 NaN

find、findIndex 可以匹配

```js
[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

#### fill()

`fill`：使用给定值，填充一个数组。（**浅拷贝**）

- value（必）：填充数据，默认填充`undefined`
- startIndex（可）：起始位置
- endIndex（可）：结束位置，不包含结束位置

```js
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]

['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```

####   entries()，keys() ，values()

`entries()`，`keys()`和`values()`：用于遍历数组。它们都返回一个遍历器对象，可以用`for...of`循环进行遍历

区别：`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

可以调用遍历器`next`方法进行遍历

```js
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
entries.next().value; // [0, 'a']
entries.next().value; // [1, 'b']
entries.next().value; // [2, 'c']
```

#### includes()

ES2016 - `includes(value, startIndex)`：返回一个布尔值，表示某个数组是否**包含给定的值** 

indexof 缺点

- 未找到，返回值为 -1 ，不够清晰
- 内部使用严格相等运算符（`===`）进行判断，这会导致对`NaN`的误判

polyfill

```js
const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false
```

`Map`和`Set`中`has`方法和 `includes`区别

- `Map` 中`has`：**查找键名**
- `Set` 中`has`：**查找值**

#### flat()，flatMap()

`flat()`：将**嵌套**的数组变成**一维**的数组

1. 返回一个**新**数组

2. 默认拉平一层

3. 会跳过空位

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]
[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]
[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
```

`flatMap(callback, bindThis)`：先执行 map，然后执行 flat （map和flat结合）。默认展开一层

```js
arr.flatMap(function callback(currentValue[, index[, array]]) {
  // ...
}[, thisArg])
```

参数说明

callback：回调函数

- `currentValue`：当前数组成员
- `index`：数组位置
- `array`：原数组

bindThis :绑定遍历函数里面的`this`

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

#### at()

问题：JavaScript 不支持数组的负索引。

```js
// 取最后一个值
arr[arr.length - 1]

arr.at(-1)
```

### 数组空位

数组的空位：数组的某一个位置没有任何值

空位：没有任何值，不是undefined

```js
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
```

ES5 - 空位处理

`forEach()`, `filter()`, `reduce()`, `every()` 、`some()`：都会跳过空位。

`map()`：跳过空位，但会保留这个值

`join()`、`toString()`：将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。

```js
// forEach方法
[,'a'].forEach((x,i) => console.log(i)); // 1

// filter方法
['a',,'b'].filter(x => x) // ['a','b']

// every方法
[,'a'].every(x => x==='a') // true

// reduce方法
[1,,2].reduce((x,y) => x+y) // 3

// some方法
[,'a'].some(x => x !== 'a') // false

// map方法
[,'a'].map(x => 1) // [,1]

// join方法
[,'a',undefined,null].join('#') // "#a##"

// toString方法
[,'a',undefined,null].toString() // ",a,,"
```

ES6 - 空位处理

`Array.from`：将数组的空位，转为`undefined`

扩展运算符（`...`）：将空位转为`undefined`

`copyWithin()`：连空位一起拷贝

`fill()`：将空位视为正常的数组位置

`for...of`：会遍历空位

`entries()`、`keys()`、`values()`、`find()`、`findIndex()`：将空位处理成`undefined`。

### sort() 的排序稳定性

排序稳定性（`stable sorting`）：排序关键字相同的项目，排序前后的顺序不变。

**插入排序、合并排序、冒泡排序**等都是稳定的

**堆排序、快速排序**等是不稳定的。

不稳定排序缺点：多重排序时可能会产生问题。

稳定排序说明：假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。

最早，`Array.prototype.sort()`是否稳定，由浏览器决定。ES2019规定，`Array.prototype.sort()`的默认排序算法必须稳定。

## 对象扩展

### 简洁表示

**属性简写**：属性名和变量名一致时

```js
// ES5
{x: x, y: y}
// ES6
{x, y}
```

**方法简写**：去掉`:`，省略`function`

```js
// ES5
method: function() {
  return "Hello!";
}
// ES6
method() {
  return "Hello!";
}
```

> 简写对象方法不能作构造函数

**tip**：对象的简洁表示法，每组键值对会打印对象名，更清晰

```js
let user = {name: 'test'};
let foo = {bar: 'baz'};

console.log(user, foo)
// {name: "test"} {bar: "baz"}
console.log({user, foo})
// {user: {name: "test"}, foo: {bar: "baz"}}
```

### 属性名表达式

**属性名**

ES5 - 只能用 **标识符**定义属性

ES6 - 允许使用**表达式**定义属性，方法名同样适用

```js
// ES5
obj.foo = true;
obj = {
  foo: true,
  abc: 123
};
// ES6
obj['a' + 'bc'] = 123;
obj = {
  [propKey]: true,
  ['a' + 'bc']: 123,
  ['h' + 'ello']() {
    return 'hi';
  }
};
```

表达式与简洁表示*不能同时使用*

```js
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

属性名表达式为对象，默认转为 `[object Object]`

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

`keyB` 会覆盖 `keyA`

### 方法name属性

函数的`name`属性，返回函数名。

对象方法

```js
const person = {
  sayName() {
    console.log('hello!');
  },
};

person.sayName.name   // "sayName"
```

get，set函数

```js
const obj = {
  get foo() {},
  set foo(x) {}
};
obj.foo.name // TypeError: Cannot read property 'name' of undefined
const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo
```

bind函数、构造函数

```js
(new Function()).name // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"
```

symbol

```js
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
```

### 属性枚举性和遍历

#### 可枚举性

对象的每个属性都有一个描述对象（`Descriptor`），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`：可以获取该属性的描述对象。

```js
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,  // 可枚举性
//    configurable: true
//  }
```

`enumerable`为`false`，可以禁用对该属性遍历。

> `toString`和`length`属性的`enumerable`都是`false`，因此`for...in`不会遍历到这两个继承自原型的属性。

|                  |                                |
| ---------------- | ------------------------------ |
| for...in         | 遍历自身属性和继承的可枚举属性 |
| Object.keys()    | 遍历自身可枚举属性键名         |
| JSON.stringify() | 串行化自身可枚举属性           |
| Object.assign()  | 拷贝自身可枚举属性             |

> 引入继承的属性会让问题复杂化，大多时候用 `Object.keys()`代替 `for...in`

ES6规定，所有 class 的原型的方法都是不可枚举的

```js
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false
```

#### 属性遍历（5种）

`for...in`：循环遍历对象自身可枚举属性和继承可枚举属性

- 自身可枚举属性、继承可枚举属性
- 不含自身不可枚举、Symbol属性

`Object.keys`：返回一个数组，包括对象自身可枚举属性的键名

- 自身可枚举属性
- 不含自身不可枚举属性、继承可枚举属性、Symbol属性

`Object.getOwnPropertyNames`：返回一个数组，包含对象自身的所有属性的键名

- 自身所有属性
- 不含继承可枚举属性、不含Symbol属性

`Object.getOwnPropertySymbols`：返回一个数组，包含对象*自身的所有 Symbol 属性*的键名

- 自身所有Symbol属性

`Reflect.ownKeys`：返回一个数组，包含对象*自身*的所有键名

- 自身属性（不管枚举性）、Symbol属性
- 不含继承属性

属性遍历的次序规则

- 首先遍历所有**数值**键，按照**数值升序**排列
- 其次遍历所有**字符串**键，按照加入**时间升序**排列
- 最后遍历所有**Symbol**键，按照加入**时间升序**排列

### super关键字

`this`：总是指向函数所在的**当前对象**

ES6 -  `super`：指向当前对象的**原型对象**

```js
const proto = {
  foo: 'hello',
  print(){
      console.log(this.foo)
  }
};

const obj = {
  foo: 'world',
  find() {
      console.log(super.foo)
  },
  print(){
      super.print()
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // "hello"
obj.print() // "world"
```

说明：`super.print()`指向`proto`中`print()`，但是绑定的`this`还是`obj`

JavaScript 引擎内部`super.foo`等同于

```js
super.foo // 属性
super.foo() // 方法
// 等价写法
Object.getPrototypeOf(this).foo
Object.getPrototypeOf(this).foo.call(this)
```

> getPrototypeOf：返回指定对象原型

注意：

super关键字表示原型对象，只能用在对象方法

以下三种写法`super`都未用在对象方法

> 对象方法：只有简写的形式能定义对象方法

```js
// 报错 用在属性中
const obj = {
  foo: super.foo
}

// 报错 用在函数中，赋值给foo属性
const obj = {
  foo: () => super.foo
}

// 报错 ...
const obj = {
  foo: function () {
    return super.foo
  }
}
```

### 对象扩展运算符

#### 解构赋值

**对象的解构赋值**：将目标对象自身所有可遍历、但尚未被读取的属性，分配到指定的对象上面

1. 不能解构 null 和 undefined
2. 扩展运算符必须在末尾
3. 解构赋值为浅拷贝
4. 不能复制继承自原型对象属性
5. 扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式

```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };// 局部解构
// 1
let { ...z } = null; // 运行时错误
let { ...z } = undefined; // 运行时错误

// 2
let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误

// 4
const o = Object.create({ x: 1, y: 2 });
o.z = 3;
let { x, ...newObj } = o; // 1 {}
let { y, z } = newObj; // undefined 3

// 5
let { x, ...{ y, z } } = o;
// SyntaxError: ... must be followed by an identifier in declaration contexts
```

`x`为解构赋值，可以读取继承属性，`y`和`z`为扩展运算符解构赋值，不能取到继承属性

#### 扩展运算符

**对象的扩展运算符**（`...`）：取出参数对象的所有可遍历属性，拷贝到当前对象之中。

1. 数组是特殊对象，扩展运算符可用于数组
2. 空对象，无效果
3. 不是对象自动转为对象
4. 字符串，自动转为类似数组对象
5. 等效于 `Object.assign()`，浅拷贝

```js
// 等同于 {...Object(1)}
{...1} // {}
{...true} // {}
{...undefined} // {}
{...null} // {}

{...'hello'}
// {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}

// 合并对象
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

Object.assign：只拷贝了对象实例属性

以下三种拷贝完整对象

```js
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

> `__proto__`属性在非浏览器的环境不一定部署，推荐写法二、三

对象同名属性规则：后面的属性会覆盖前面的属性

```js
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
```

应用：修改部分属性

```js
let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};
```

自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。

```js
let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
```

与数组相同，后面可跟表达式

```js
const obj = {
  ...(x > 1 ? {a: 1} : {}),
  b: 2,
};
```

会执行取值函数`get`

```js
let a = {
  get x() {
    throw new Error('not throw yet');
  }
}

let aWithXGetter = { ...a }; // 报错
```

### AggregateError 错误对象

ES2021 - 为了配合新增的`Promise.any()`方法，还引入一个新的错误对象`AggregateError`

作用：封装了多个错误对象，单一操作可以抛出多个错误

```js
AggregateError(errors[, message])
```

- errors（必）： 数组，它的每个成员都是一个错误对象
- message（选）：字符串，表示 AggregateError 抛出时的提示信息

```js
const error = new AggregateError([
  new Error('ERROR_11112'),
  new TypeError('First name must be a string'),
  new RangeError('Transaction value must be at least 1'),
  new URIError('User profile link must be https'),
], 'Transaction cannot be processed')
```

## 对象的新增方法

### Object.is()

ES5比较值，`==`或`===`

- `==`：会自动转换数据类型
- `===`：`NaN`不等于自身，`+0`等于`-0`

 ES6 - `Object.is()`：比较两个值是否严格相等。与`===`基本一致，唯一不同 +0 不等于 -0

```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

polyfill

```js
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      // 1 / -0  -Infinity
      // 1 / +0  +Infinity
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
```

### Object.assign()

`Object.assign()`：将源**自身**对象所有**可枚举属性**（含*Symbol*），复制到目标对象

#### 参数

第一参数：目标对象
- 只有一个参数，直接返回
- 不是对象转换为对象，`undefined`和 `null`无法转为对象，报错

后面参数：源对象
- 不是对象转换为对象（数组也是）
- 字符串会以数组形式拷贝，其他值（Boolean，Number，undefined、null）忽略

#### 注意

1. 浅拷贝
2. 同名参数，源对象覆盖目标对象，后面源对象覆盖前面源对象
3. 数组处理

```js
Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
```

4. 取值函数处理：先取值再处理

```js
const source = {
  get foo() { return 1 }
};
const target = {};

Object.assign(target, source)
// { foo: 1 }
```

#### 用途

1. 为对象添加属性
2. 为对象添加方法
3. 克隆对象

```js
// 只能克隆自身值，无法保证继承链
function clone(origin) {
  return Object.assign({}, origin);
}
```

```js
function clone(origin) {
  let originProto = Object.getPrototypeOf(origin);
  return Object.assign(Object.create(originProto), origin);
}
```

4. 合并对象
5. 指定默认值

### getOwnPropertyDescriptors()

ES5 - `Object.getOwnPropertyDescriptor()`：返回**某个**对象**属性的描述对象**（descriptor）。

ES2017 - `Object.getOwnPropertyDescriptors()`：返回指定对象**所有自身属性的描述对象**

polyfill

```js
function getOwnPropertyDescriptors(obj) {
  const result = {};
  for (let key of Reflect.ownKeys(obj)) {
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return result;
}
```

问题：`Object.assign()`无法正确拷贝 `get` 和 `set` 属性。Object.assign只会拷贝属性值，不会赋值、取值方法

```js
const source = {
  set foo(value) {
    console.log(value);
  }
};

const target1 = {};
Object.assign(target1, source);

Object.getOwnPropertyDescriptor(target1, 'foo')
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }
```

解决：defineProperties + getOwnPropertyDescriptors

```js
const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
```

配合`Object.create()`方法，将对象属性克隆到新对象（**浅拷贝**）

```js
const clone = Object.create(Object.getPrototypeOf(obj),
Object.getOwnPropertyDescriptors(obj));
```

对象继承

ES5

```js
const obj = {
  __proto__: prot,
  foo: 123,
};
```

ES6
```js
const obj = Object.create(prot);
obj.foo = 123;

// 或者

const obj = Object.assign(
  Object.create(prot),
  {
    foo: 123,
  }
);
```

另一种写法

```js
const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
```

实现**混入**模式

```js
let mix = (object) => ({
  with: (...mixins) => mixins.reduce(
    (c, mixin) => Object.create(
      c, Object.getOwnPropertyDescriptors(mixin)
    ), object)
});

// multiple mixins example
let a = {a: 'a'};
let b = {b: 'b'};
let c = {c: 'c'};
let d = mix(c).with(a, b);

d.c // "c"
d.b // "b"
d.a // "a"
```

### \_\_proto__

`__proto__`：读取或设置当前对象原型对象，实际是调用`Object.prototype.__proto__`

```js
// es5 的写法
const obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
```

实现如下

```js
Object.defineProperty(Object.prototype, '__proto__', {
  get() {
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  },
  set(proto) {
    if (this === undefined || this === null) {
      throw new TypeError();
    }
    if (!isObject(this)) {
      return undefined;
    }
    if (!isObject(proto)) {
      return undefined;
    }
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) {
      throw new TypeError();
    }
  },
});

function isObject(value) {
  return Object(value) === value;
}
```

### setPrototypeOf()

与`__proto__`相同，设置对象原型对象（**推荐**）

```js
Object.setPrototypeOf(object, prototype)
// 等效
function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```

说明

1. 第一参数不是对象，会自动转对象，此函数返回值为第一参数，所以操作无效。

```js
Object.setPrototypeOf(1, {}) === 1 // true
Object.setPrototypeOf('foo', {}) === 'foo' // true
Object.setPrototypeOf(true, {}) === true // true
```

2. 第一参数为`undefined`，`null`会报错

```js
Object.setPrototypeOf(undefined, {})
// TypeError: Object.setPrototypeOf called on null or undefined

Object.setPrototypeOf(null, {})
// TypeError: Object.setPrototypeOf called on null or undefined
```

### getPrototypeOf()

读取一个对象的原型对象

不是对象，转对象，`undefined`、`null`报错

```js
Object.getPrototypeOf(1) === Number.prototype // true
Object.getPrototypeOf('foo') === String.prototype // true
Object.getPrototypeOf(true) === Boolean.prototype // true
```

### keys()、values()、entries()

ES5 - `Object.keys`：返回一个数组，成员是**键名**。（可遍历属性、非Symbol、不含继承）

ES2017 - `Object.values`：返回一个数组，成员是**键值**。（可遍历属性、非Symbol、不含继承）

说明

1. 会过滤属性名为 Symbol 值的属性

```js
Object.values({ [Symbol()]: 123, foo: 'abc' });
// ['abc']
```

2. 值为字符串，返回字符串组成的数组

```js
Object.values('foo')
// ['f', 'o', 'o']
```

3. 数值、布尔值，返回空数组（不是对象转对象，而这两者包装对象都不会添加非继承属性）

`Object.entries()`：返回一个数组，成员是**键名 + 键值**（可遍历属性、非Symbol、不含继承）

```js
const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: "bar", baz: 42 }
```

polyfill

```js
// Generator函数的版本
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

// 非Generator函数的版本
function entries(obj) {
  let arr = [];
  for (let key of Object.keys(obj)) {
    arr.push([key, obj[key]]);
  }
  return arr;
}
```

### formEntries()

`Object.fromEntries()`：`Object.entries()`的逆操作，用于将一个键值对数组转为*对象*。

应用：将 Map 结构转为对象

```js
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);
Object.fromEntries(entries)
// { foo: "bar", baz: 42 }

const map = new Map().set('foo', true).set('bar', false);
Object.fromEntries(map)
// { foo: true, bar: false }
```

配个`URLSearchParams`对象，查询字符串转对象

```js
Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'))
// { foo: "bar", baz: "qux" }
```

补充：[URLSearchParams](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)

```js
var paramsString = "q=URLUtils.searchParams&topic=api"
var searchParams = new URLSearchParams(paramsString);

for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams
```

## 运算符扩展

### 指数运算符

ES2016 新增了一个指数运算符（`**`）

```js
2 ** 2 // 4
2 ** 3 // 8
```

### 链判断运算符

读取对象内部的某个属性，需要判断一下该对象是否存在。

三元运算符`?:`也常用于判断对象是否存在。

```js
const fooValue = fooInput ? fooInput.value : undefined
```

ES2020 - 链判断运算符`?.`：左侧对象是否为null 或 undefined。如果是，返回undefined，如果不是，继续运算

#### 三种写法

```js
// 属性
const fooValue = fooInput?.value
// 动态属性
obj?.[expr]
// 函数、方法调用
func?.(...args)
```

#### 注意点

短路机制：不满足条件，不向下执行。如果左侧为真，++x不执行

```js
a?.[++x]
// 等同于
a == null ? undefined : a[++x]
```

括号影响：属性链有圆括号，链判断运算符*对圆括号外部没有影响*

```js
(a?.b).c
// 等价于
(a == null ? undefined : a.b).c
```

delete运算符

```js
delete a?.b
// 等同于
a == null ? undefined : delete a.b
```

报错场合：以下均不合法

1. 构造函数
2. 右侧为模板字符串
3. super函数
4. 左侧为赋值运算符
5. 右侧为十进制

```js
// 构造函数
new a?.()
new a?.b()

// 右侧有模板字符串
a?.`{b}`
a?.b`{c}`

// super函数
super?.()
super?.foo

// 左侧用于赋值运算符
a?.b = c

// 右侧为十进制
foo?.3:0
// 为了保证兼容性，会被解析为 foo ? .3 : 0
```

### Null判断运算符

ES5 - 通过 `||` 指定默认值， 值为`null`或`undefined`，默认值生效

问题：`false`或`0`触发默认值

```js
const default = val || 'world'
```

ES2020 -   Null 判断运算符`??`：类似`||`，但  `false` 或 `0` 不会触发

`??`有一个运算优先级问题，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。

```js
lhs && middle ?? rhs // 报错

(lhs && middle) ?? rhs;
lhs && (middle ?? rhs);
```

### 逻辑赋值运算符

ES2021 -  引入了三个新的逻辑赋值运算符（`||=  &&=  ??=`)

```js
// 或赋值运算符
x ||= y
// 等同于
x || (x = y)

// 与赋值运算符
x &&= y
// 等同于
x && (x = y)

// Null 赋值运算符
x ??= y
// 等同于
x ?? (x = y)
```

用法

```js
function example(opts) {
  opts.foo = opts.foo ?? 'bar';
  opts.baz ?? (opts.baz = 'qux');
}
```

```js
function example(opts) {
  opts.foo ??= 'bar';
  opts.baz ??= 'qux';
}
```

